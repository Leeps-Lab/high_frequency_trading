{% extends "global/Page.html" %}
{% load staticfiles otree %}
{% load staticfiles %}

{% block content %}

<div class="front-end-controller">
    <div class="top-banner">
        <table class="table" style="width:100%" >
            <!-- Row 1 of info box -->
            <tr>
                <td class="info_text">Player ID:            <span id="player_id"></span></td>
                <td class="info_text">Number of Traders:    <span id="num_traders"></span></td>
                <td class="info_text">Role:                 <span id="player_role"> </span> </td>
                <td class="info_text">Fundamental Value:    <span id="fp"></span></td>
            </tr>
            <!-- Row 2 of info box -->
            <tr>
                <td class="info_text">Period:               <span id="period_id"></span></td>
                <td class="info_text">Number of Makers:     <span id=num_makers></span></td>
                <td class="info_text">Spread:               <span id="spread_value"></span> </td>
                <td class="info_text">Current Buy Price:    <span id="curr_bid"></span></td>
            </tr>
            <!-- Row 3 of info box -->
            <tr>
                <td class="info_text">Speed Cost:           <span id="speed_cost"></span></td>
                <td class="info_text"></td>
                <td class="info_text">Your Profit:          <span id="profit"></span></td>
                <td class="info_text">Current Sell Price:   <span id="curr_ask"></span></td>
            </tr>
        </table>
    </div>

    <div class="graph-row" id="graph-row">

        <div class="profit-graph-container">
            <svg id="profit-graph" style="width:100%; height:100%;"></svg>
        </div>

        <div class="spread-graph-container">
            <svg id="spread-graph" style="width:100%; height:100%;"></svg> 
        </div>

            
        <div class="inputs">
            <div class="button-container">
                <div class="row" style="padding-bottom:3em">
                    <button id="out" value="out" class="button-on" type="button" style="width:75px">
                        Out   
                    </button>
                </div>
                <div class="row" style="padding-bottom:3em">
                    <button id="sniper" value="sniper" class="button-off" type="button" style="width:75px">
                        Snipe
                    </button> 
                </div>
                <div class="row">
                    <button id="maker" value="maker" class="button-off" type="button" style="width:75px">
                        Maker
                    </button>
                </div>
            </div>
            <div class="button-container-speed">
                    <p  style="text-align: center; margin-left: 30px; margin-top:50px;">Speed</p>
                    <label class="switch" style="margin-left: 40px; margin-top: -5px;" >
                        <br>
                        <input id="speed-btn" type="checkbox" onclick="updatespeed()" disabled="true">
                        <span class="slider round"></span>
                    </label>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
    <script src="https://d3js.org/d3.v5.js"></script>
    <script src="https://momentjs.com/downloads/moment.js"></script>
    <script src="https://momentjs.com/downloads/moment-timezone.min.js"></script>
    <link rel="stylesheet" href="{% static "oTree_HFT_CDA/profit-graph.css" %}">
    <link rel="stylesheet" href="{% static "oTree_HFT_CDA/slider.css" %}">
    <link rel="stylesheet" href="{% static "oTree_HFT_CDA/start.css" %}">
    <link rel="stylesheet" href="{% static "oTree_HFT_CDA/buttons.css" %}">
    <link rel="stylesheet" href="{% static "oTree_HFT_CDA/spread-graph.css" %}">
    <!-- <link rel="stylesheet" href="{% static "oTree_HFT_CDA/js/spread-graph.js" %}"> -->
    <!-- <link rel="stylesheet" src="{% static "oTree_HFT_CDA/js/profit-graph.js" %}"> -->
    <!-- <script src="{% static "oTree_HFT_CDA/js/profit-graph.js" %}"></script> -->

    <script>

/*Front End Javascript for start.html*/
/*Handles the Button Logic and the Graph shown in start.html*/

window.onload = function () {

    // Establish websocket variables
    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
    var socket = new WebSocket(ws_scheme + '://' + window.location.host + "/hft/{{group.id}}/{{player.id}}/");
    console.log(socket);

    // Handle any errors that occur.
    socket.onerror = function (error) {
        console.log('WebSocket Error: ' + error);
    };

    // Show a connected message when the WebSocket is opened.
    socket.onopen = function (event) {
        console.log('Client has connected to django channels');
    };

    // Handle messages sent by the server.
    socket.onmessage = function (event) {
        var obj = jQuery.parseJSON(event.data);

        if(obj.FPC != undefined){
            Spread_Graph.drawMyLine({}, 0, {}, true);
            var difference = $('#fp').text() - obj.FPC;
            $('#fp').html(obj.FPC);
            Spread_Graph.clear();
            Spread_Graph.drawMyLine({}, difference / 10);

            for(var key in spread_lines){
                for(var token in spread_lines[key]){
                    spread_lines[key][token] -= parseInt(difference);
                    spread_lines[key][token] -= parseInt(difference);
                }
            }


            setTimeout(function(){
                Spread_Graph.clear();
                Spread_Graph.drawMyLine({}, 0);
            },500);
        }else if(obj.EXEC != undefined){
            var timeNow = getTime() - graph.timeOffset;

            var exec = {};
            exec["player"] = obj.EXEC.id;
            exec["side"] = obj.EXEC.token[4];
            exec["profit"] = obj.EXEC.profit;
            
            Spread_Graph.clear();
            Spread_Graph.drawMyLine({}, 0, exec);

            if(obj.EXEC.id == parseInt($("#player_id").text())){
                graph.profitJumps.push(
                    {
                        timestamp:timeNow,
                        oldProfit:graph.profit,
                        newProfit:graph.profit + obj.EXEC.profit, 
                    }
                );
                graph.profit += obj.EXEC.profit;

                graph.profitSegments.push(
                    {
                        startTime:timeNow,
                        endTime:timeNow, 
                        startProfit:graph.profit, 
                        endProfit:graph.profit,
                        state:$("#player_role").text()
                    }
                )   
            }
        }else if(obj.SPRCHG != undefined){
            Spread_Graph.clear();
            for(var key in obj.SPRCHG){
                // if(obj.SPRCHG[key] == 0 && smallest_spread[key] != undefined){
                //     delete obj.SPRCHG[key];
                //     updateSmallest(key);
                // }
                delete spread_lines[key];
            }

            // for(var key in obj.SPRCHG){
            //     if((obj.SPRCHG[key]["A"] - obj.SPRCHG[key]["B"]) < smallest_spread["spread"]){
            //         smallest_spread["key"] = key;
            //         smallest_spread["spread"] = obj.SPRCHG[key]["A"] - obj.SPRCHG[key]["B"]
            //     }
            // }

            Spread_Graph.drawMyLine(obj.SPRCHG);
            
        }else if(obj.SYNC != undefined){
            // its go time
            $(':button').prop('disabled', false);
            Spread_Graph.disabled = false;

            graph.adminStartTime = getTime();
            init(startFP, startingWealth, "secondTick");

            requestAnimationFrame(draw)


            $('#player_id').html({{player.id_in_group}});
            $('#period_id').html(1);
            $('#speed_cost').html(0);

            $('#num_traders').html({{subsession.players_per_group}});
            $('#num_makers').html(0);
            
            $('#player_role').html('OUT');
            $('#spread_value').html('N/A');
            $('#profit').html(20);

            $('#fp').html({{player.default_fp}});
            $('#curr_bid').html('N/A');
            $('#curr_ask').html('N/A');

            var round_length = {{subsession.round_length}} * 1000
            console.log(round_length);
            window.setTimeout(function(){
                console.log("edning");
                var msg = {
                    type: 'advance_me',
                };
                if (socket.readyState === socket.OPEN) {
                    socket.send(JSON.stringify(msg));
                }
        
                $(':button').prop('disabled', true);
                Spread_Graph.disabled = true;

            }, round_length);

            

        }
       

        // switch statement on type of data parsed from event
    };

    // Show a disconnected message when the WebSocket is closed.
    socket.onclose = function (event) {
        console.log('disconnected from oTree');
    };


    $(':button').prop('disabled', true);

    window.setTimeout(function(){
        var msg = {
            type: 'player_ready',
        };
        if (socket.readyState === socket.OPEN) {
            console.log("Sending")
            socket.send(JSON.stringify(msg));
        }
    },2000);

    // function endRound(){
    //     console.log("edning");
    //     var msg = {
    //         'type': 'advance_me',
    //     };
    //     if (socket.readyState === socket.OPEN) {
    //         socket.send(JSON.stringify(msg));
    //     }

    //     $(':button').prop('disabled', true);
    //     Spread_Graph.disabled = true;
    // }


    // On load global var? Terrible
    var speed = false;


    // Called on click to toggle input
    updatespeed = function () {
        speed = !speed;
        if(speed){
            $('#speed_cost').html({{player.speed_cost}});
        }else {
            $('#speed_cost').html(0);
        }
        var timeNow = getTime() - graph.timeOffset;
        graph.profitSegments.push(
            {
                startTime:timeNow,
                endTime:timeNow, 
                startProfit:graph.profit, 
                endProfit:graph.profit,
                state:$("#player_role").text()
            }
        );

        var msg = {
            type: 'speed_change',
            id: {{player.id}},
            id_in_group: {{player.id_in_group}},
            speed: speed
        };
        if (socket.readyState === socket.OPEN) {
            socket.send(JSON.stringify(msg));
        }
    }


    document.getElementById("maker").onclick = function () {
        if ((document.getElementById("maker").className == "button-off") && (document.getElementById("maker").className != "button-pressed")){
            //IF BUTTON IS NOT PRESSED OR ON THEN TURN IT ON AFTER DELAD (Button_Pressed())
            $("#maker").toggleClass('button-off button-pressed');
            $('#player_role').html('MAKER');

            document.getElementById("speed-btn").disabled = false;

            var timeNow = getTime() - graph.timeOffset;
            graph.profitSegments.push(
                {
                    startTime:timeNow,
                    endTime:timeNow, 
                    startProfit:graph.profit, 
                    endProfit:graph.profit,
                    state:$("#player_role").text()
                }
            );


            var msg = {
                type: 'role_change',
                id: {{player.id}},
                id_in_group: {{player.id_in_group}},
                state: "MAKER"
            };
            if (socket.readyState === socket.OPEN) {
              socket.send(JSON.stringify(msg));
            }

            Button_Pressed("maker");

        }
        $("#out").attr('class', 'button-off');
        $("#sniper").attr('class', 'button-off');
    };

    document.getElementById("sniper").onclick = function () {
        if ((document.getElementById("sniper").className == "button-off") && (document.getElementById("sniper").className != "button-pressed")){
            //IF BUTTON IS NOT PRESSED OR ON THEN TURN IT ON AFTER DELAD (Button_Pressed())
            $("#sniper").toggleClass('button-off button-pressed');
            $('#player_role').html('SNIPER');

            document.getElementById("speed-btn").disabled = false;


            var timeNow = getTime() - graph.timeOffset;
            graph.profitSegments.push(
                {
                    startTime:timeNow,
                    endTime:timeNow, 
                    startProfit:graph.profit, 
                    endProfit:graph.profit,
                    state:$("#player_role").text()
                }
            );

            var msg = {
                type: 'role_change',
                id: {{player.id}},
                id_in_group: {{player.id_in_group}},
                state: "SNIPER"
            };
            if (socket.readyState === socket.OPEN) {
                socket.send(JSON.stringify(msg));
            }
            Button_Pressed("sniper");

            Spread_Graph.clear();
            delete spread_lines[parseInt($("#player_id").text())]

        }

        $("#maker").attr('class', 'button-off');
        $("#out").attr('class', 'button-off');
    };

  //OUT BUTTON
    document.getElementById("out").onclick = function () {
        if (document.getElementById("out").className == "button-off"){
            //IF THE BUTTON IS OFF TURN IT ON WITH NO DELAY
            $("#out").toggleClass('button-off button-on');
            $('#player_role').html('OUT');
            document.getElementById("speed-btn").disabled = true;
            
            
            var timeNow = getTime() - graph.timeOffset;
            graph.profitSegments.push(
                {
                    startTime:timeNow,
                    endTime:timeNow, 
                    startProfit:graph.profit, 
                    endProfit:graph.profit,
                    state:$("#player_role").text()
                }
            );

            var msg = {
                type: 'role_change',
                id: {{player.id}},
                id_in_group: {{player.id_in_group}},
                state: "OUT"
            };
            if (socket.readyState === socket.OPEN) {
                socket.send(JSON.stringify(msg));
            }
            Button_Pressed("out");
            
            if(speed){
                updatespeed();
                document.getElementById("speed-btn").checked = false;
            }

            Spread_Graph.clear();
            delete spread_lines[parseInt($("#player_id").text())]

        }

        $("#maker").attr('class', 'button-off');
        $("#sniper").attr('class', 'button-off');
    };

    var button_timer;
    var graph_timer;
    function Button_Pressed(id_name){
        //Wait .5 seconds for button pressed to even for fast players
        // to eliminate spam clicking
        button_timer = setTimeout(Button_Change.bind(null,id_name),500);
    }
    function Button_Change(id_name){
        //TURNING BUTTON ON
        if(id_name == "out" || id_name == "maker"){
            $("#"+id_name).toggleClass('button-pressed button-on');
        }else if (id_name == "sniper"){
            $("#"+id_name).toggleClass('button-pressed button-on-sniper');

        }
    }

    var Spread_Graph = {};
    Spread_Graph.dis = true;
  
    
    var id;
    var spread_lines = {};

    var max_spread = 2000; // Pull from Constansts
    var default_spread = 1000;

    var smallest_spread = {"key":-1, "spread":max_spread};


    // Functions for drawing choice box
    (function() {

        var spread_width = $("#spread-graph").width(),
            spread_height = $("#spread-graph").height(),
            spread_svg = d3.select("#spread-graph")
            .attr("width", spread_width)
            .attr("height", spread_height);

        
        // center vertical line
        function drawStartState(){
            spread_line = spread_svg.append("svg:line")
                .attr("x1", spread_width/2)
                .attr("y1", 0)
                .attr("x2", spread_width/2)
                .attr("y2", spread_height)
                .style("stroke", "lightgrey")
                .style("stroke-width", 5);

            spread_line_fundamental_price = spread_svg.append("svg:line")
                .attr("x1", 0 + 60)
                .attr("y1", spread_height/2)
                .attr("x2", spread_width - 60)
                .attr("y2", spread_height/2)
                .style("stroke", "grey")
                .style("stroke-width", 3);

        }

        function updateSmallest(key){
            delete smallest_spread[key];
            smallest_spread[-1] = max_spread;
            for(var key in spread_lines){
                if((spread_lines[key]["A"] - spread_lines[key]["B"]) < smallest_spread["spread"]){
                    smallest_spread["key"] = key;
                    smallest_spread["spread"] = spread_lines[key]["A"] - spread_lines[key]["B"]
                }
            }
        }

        function svgClickListener(){
            // if(Spread_Graph.disabled == true){
            //     return;
            // }
            spread_svg.on('click',function(d) { 
                role = $("#player_role").text();
                if(role == "MAKER"){

                    //The dimensions the svg take up
                    spread_x = document.getElementById("spread-graph").getBoundingClientRect().left;
                    spread_y = document.getElementById("spread-graph").getBoundingClientRect().top;

                    //Where the grey middle line is
                    svg_middle_x = spread_width / 2;
                    fp_line_y = spread_height / 2;

                    //The tuple in which the mouse is clicked within the svg 
                    click_point = {
                        x:(d3.event.clientX - spread_x),
                        y:(d3.event.clientY - spread_y)
                    };

                    //finding the distance from the mid
                    distance_from_middle = Math.abs(click_point.y - fp_line_y);

                    ratio = distance_from_middle / (spread_height / 2);

                    my_spread = (ratio * max_spread).toFixed(0);

                    sendSpreadChange(my_spread);

                }else if(role == "OUT"){
                    //IF BUTTON IS NOT PRESSED OR ON THEN TURN IT ON AFTER DELAD (Button_Pressed())
                    $("#maker").toggleClass('button-off button-pressed');
                    $('#player_role').html('MAKER');

                    var timeNow = getTime() - graph.timeOffset;
                    graph.profitSegments.push(
                        {
                            startTime:timeNow,
                            endTime:timeNow, 
                            startProfit:graph.profit, 
                            endProfit:graph.profit,
                            state:$("#player_role").text()
                        }
                    );


                    var msg = {
                        type: 'role_change',
                        id: {{player.id}},
                        id_in_group: {{player.id_in_group}},
                        state: "MAKER"
                    };
                    if (socket.readyState === socket.OPEN) {
                        socket.send(JSON.stringify(msg));
                    }

                    Button_Pressed("maker");

                    $("#out").attr('class', 'button-off');

                    //The dimensions the svg take up
                    spread_x = document.getElementById("spread-graph").getBoundingClientRect().left;
                    spread_y = document.getElementById("spread-graph").getBoundingClientRect().top;

                    //Where the grey middle line is
                    svg_middle_x = spread_width / 2;
                    fp_line_y = spread_height / 2;

                    //The tuple in which the mouse is clicked within the svg 
                    click_point = {
                        x:(d3.event.clientX - spread_x),
                        y:(d3.event.clientY - spread_y)
                    };

                    //finding the distance from the mid
                    distance_from_middle = Math.abs(click_point.y - fp_line_y);

                    ratio = distance_from_middle / (spread_height / 2);

                    my_spread = (ratio * max_spread).toFixed(0);

                    sendSpreadChange(my_spread);
                }
            });
        }

        function drawMySpreadLines(newLines={}, offset=0, exec={}, inv=false){
            var exec_side = "";
            var exec_spread = "";
            for(var key in spread_lines){
                if(key == parseInt($('#player_id').text())){
                    spread_y = document.getElementById("spread-graph").getBoundingClientRect().top;
                    //Where the grey middle line is
                    svg_middle_y = spread_height/2;
                    my_spread = parseInt(spread_lines[key]["A"] - spread_lines[key]["B"]);
                    money_ratio =  max_spread/my_spread;
                    y_coordinate = svg_middle_y/money_ratio;
                    var lines = [];
                    

                    if(exec.player != key || exec.side != "S"){
                        your_spread_line_top = spread_svg.append("svg:line")
                            .attr("x1", (spread_width / 2) - 25)
                            .attr("y1", svg_middle_y - y_coordinate + offset)
                            .attr("x2", (spread_width / 2) + 25)
                            .attr("y2", svg_middle_y - y_coordinate + offset)
                            .attr("stroke-width",3)
                            .attr("class","my_line");
                            
                        lines.push(your_spread_line_top);
                    }else if(exec.player == key && exec.side == "S"){
                        exec_side = "S";
                        exec_spread = my_spread;
                    }

                    if(exec.player != key || exec.side != "B"){          
                        your_spread_line_bottom = spread_svg.append("svg:line")
                            .attr("x1", (spread_width / 2) - 25)
                            .attr("y1", y_coordinate + svg_middle_y + offset)
                            .attr("x2", (spread_width / 2) + 25)
                            .attr("y2", y_coordinate + svg_middle_y + offset)
                            .attr("stroke-width",3)
                            .attr("class","my_line");
                        lines.push(your_spread_line_bottom);
                    }else if(exec.player == key && exec.side == "B"){
                        exec_side = "B";
                        exec_spread = my_spread;
                    } 

                    addOthersLineAnimation(lines, 0, 25);
                    drawSpreadBar(my_spread,svg_middle_y,y_coordinate, offset, key);

                    if(exec_side != ""){
                        drawTransactionBar(exec_spread, svg_middle_y,y_coordinate, exec_side,((exec.profit > 0) ? "transaction_bar_light_green" : "transaction_bar_light_red"));
                    }

                }else{
                    spread_y = document.getElementById("spread-graph").getBoundingClientRect().top;
                    var lines = [];
                    //Where the grey middle line is
                    svg_middle_y = spread_height/2;
                    my_spread = parseInt(spread_lines[key]["A"] - spread_lines[key]["B"]);
                    money_ratio =  max_spread/my_spread;
                    y_coordinate = svg_middle_y/money_ratio;
                    // console.log(y_coordinate);
                    //Ratio between the distance and the mid
                    if(exec.player != key || exec.side != "S"){
                        your_spread_line_top = spread_svg.append("svg:line")
                            .attr("x1", (spread_width / 2) - 15)
                            .attr("y1", svg_middle_y - y_coordinate + offset)
                            .attr("x2", (spread_width / 2) + 15)
                            .attr("y2", svg_middle_y - y_coordinate + offset)
                            .attr("stroke-width",1)
                            .attr("class","others_line");
                        lines.push(your_spread_line_top);
                    }else if(exec.player == key && exec.side == "S"){
                        exec_side = "S";
                        exec_spread = my_spread;
                    }

                    if(exec.player != key || exec.side != "B"){
                        your_spread_line_bottom = spread_svg.append("svg:line")
                            .attr("x1", (spread_width / 2) - 15)
                            .attr("y1", y_coordinate + svg_middle_y + offset)
                            .attr("x2", (spread_width / 2) + 15)
                            .attr("y2", y_coordinate + svg_middle_y + offset)
                            .attr("stroke-width",1)
                            .attr("class","others_line");
                        lines.push(your_spread_line_bottom);
                    }else if(exec.player == key && exec.side == "B"){
                        exec_side = "B";
                        exec_spread = my_spread;
                    }

                    addOthersLineAnimation(lines, 0, 15);
                    if(exec_side != ""){
                        drawTransactionBar(my_spread,svg_middle_y,y_coordinate,exec_side, ((exec.profit > 0) ? "transaction_bar_dark_green" : "transaction_bar_dark_red"));
                    }
                }
                
                

            }

            for(var key in newLines){
                if(key == parseInt($('#player_id').text())){
                    // d3.selectAll(".my_line").remove();
                    spread_y = document.getElementById("spread-graph").getBoundingClientRect().top;
                    //Where the grey middle line is
                    svg_middle_y = spread_height / 2;
                    
                    my_spread = parseInt(newLines[key]["A"] - newLines[key]["B"]);

                    money_ratio =  max_spread/my_spread;
                    y_coordinate = svg_middle_y/money_ratio;
                    // console.log(y_coordinate);
                    //Ratio between the distance and the mid
                    your_spread_line_top = spread_svg.append("svg:line")
                        .attr("x1", spread_width)
                        .attr("y1", svg_middle_y - y_coordinate + offset)
                        .attr("x2", spread_width - 25)
                        .attr("y2", svg_middle_y - y_coordinate + offset)
                        .attr("stroke-width",3)
                        .attr("class","my_line");
                
                    your_spread_line_bottom = spread_svg.append("svg:line")
                        .attr("x1", spread_width)
                        .attr("y1", y_coordinate + svg_middle_y + offset)
                        .attr("x2", spread_width - 25)
                        .attr("y2", y_coordinate + svg_middle_y + offset)
                        .attr("stroke-width",3)
                        .attr("class","my_line");

                    addOthersLineAnimation([your_spread_line_top, your_spread_line_bottom], 500, 25); 

                    setTimeout(function(d){
                        drawSpreadBar(my_spread,svg_middle_y,y_coordinate, offset, key);
                    }, 500);
                }else{
                    spread_y = document.getElementById("spread-graph").getBoundingClientRect().top;

                    //Where the grey middle line is
                    svg_middle_y = spread_height/2;
                    my_spread = parseInt(newLines[key]["A"] - newLines[key]["B"]);
                    money_ratio =  max_spread/my_spread;
                    y_coordinate = svg_middle_y/money_ratio;
                    // console.log(y_coordinate);
                    your_spread_line_top = spread_svg.append("svg:line")
                        .attr("x1", spread_width)
                        .attr("y1", svg_middle_y - y_coordinate)
                        .attr("x2", spread_width - 15)
                        .attr("y2", svg_middle_y - y_coordinate)
                        .attr("stroke-width",1)
                        .attr("class","others_line");

                
                    your_spread_line_bottom = spread_svg.append("svg:line")
                        .attr("x1", spread_width)
                        .attr("y1", y_coordinate + svg_middle_y)
                        .attr("x2", spread_width - 15)
                        .attr("y2", y_coordinate + svg_middle_y)
                        .attr("stroke-width",1)
                        .attr("class","others_line");
                    // for removing when a transation occurs

                    addOthersLineAnimation([your_spread_line_top, your_spread_line_bottom], 500, 15);
                }
                spread_lines[key] = newLines[key];
            }
            
            if(inv == true){
                spread_line_fundamental_price = spread_svg.append("svg:line")
                    .attr("x1", 0 + 50)
                    .attr("y1", spread_height/2)
                    .attr("x2", spread_width - 50)
                    .attr("y2", spread_height/2)
                    .style("stroke", "yellow")
                    .style("stroke-width", 10)
                    .attr("class", "inv-line");
            }
            
            spread_line_fundamental_price = spread_svg.append("svg:line")
                .attr("x1", 0 + 60)
                .attr("y1", spread_height/2)
                .attr("x2", spread_width - 60)
                .attr("y2", spread_height/2)
                .style("stroke", "grey")
                .style("stroke-width", 3);

            if(inv == true){
                setTimeout(function(){
                    d3.selectAll(".inv-line").remove();
                },400);
            }

        }




        function addOthersLineAnimation(lines, speed=500, width){
            //SETTING THE SPREAD TO THE LINE
            for( i = 0; i < lines.length; i++){
                add_animation = lines[i]
                  .transition()
                  .duration(speed)
                  .attr("x1", (spread_width / 2) + width)
                  .attr("x2", (spread_width / 2) - width);
            }      
          
        }
  

        function drawTransactionBar(my_spread,svg_middle_y,y_coordinate, side, color){
            //take into account
            var bar_color = color;

            //if not other maker within the spread
            if(side == "B"){
                your_bar_rect = spread_svg.append("svg:rect")
                    .attr("x", (spread_width / 2) - 5)
                    .attr("y", svg_middle_y)
                    .attr("width", 10)
                    .attr("height",y_coordinate)
                    .attr("class",bar_color);
            } else if(side == "S"){
                your_bar_rect = spread_svg.append("svg:rect")
                        .attr("x", (spread_width / 2) - 5)
                        .attr("y", svg_middle_y - y_coordinate)
                        .attr("width", 10)
                        .attr("height", y_coordinate)
                        .attr("class",bar_color);
            }
            setTimeout(function(){
                d3.selectAll(".transaction_bar_light_green").remove();
                d3.selectAll(".transaction_bar_light_red").remove();
                d3.selectAll(".transaction_bar_dark_green").remove();
                d3.selectAll(".transaction_bar_dark_red").remove();
            },400);
        }

        function drawSpreadBar(my_spread,svg_middle_y,y_coordinate, offset, id){
            //take into account
            var bar_color = "";

            //if not other maker within the spread
            if(id == smallest_spread["key"]){
                bar_color = "green_bar";
            }else{
                bar_color = "blue_bar";
            }
            your_bar_rect = spread_svg.append("svg:rect")
                       .attr("x", (spread_width / 2) - 25)
                       .attr("y", svg_middle_y - y_coordinate + offset)
                       .attr("width", 50)
                       .attr("height", 2*y_coordinate)
                       .attr("class",bar_color);
        }

        function clearGraph(){
            d3.selectAll(".my_line").remove();
            d3.selectAll(".others_line").remove();
            d3.selectAll("rect").remove();
        }

        function sendSpreadChange(my_spread){

            var msg = {
                type: 'spread_change',
                id: {{player.id}},
                id_in_group: {{player.id_in_group}},
                spread: my_spread
            };
            if (socket.readyState === socket.OPEN) {
                socket.send(JSON.stringify(msg));
            }
            $("#spread_value").text('+-$'+(my_spread / 1000).toFixed(2));
        }

        Spread_Graph.start = drawStartState;
        Spread_Graph.drawMyLine = drawMySpreadLines;
        Spread_Graph.drawBar = drawSpreadBar;
        Spread_Graph.listen = svgClickListener;
        Spread_Graph.clear = clearGraph;
        Spread_Graph.spread = sendSpreadChange;
    }());

Spread_Graph.start();
Spread_Graph.listen();

 // global variable 
var graph = {};

/*
    * Debug variables
    */
graph.debug = {
    "calcTimeGridLines"    :false,
    "secondTick"           :false,
};


/*
    * set of variables we added that were not part of the original solution
    */
graph.maxSpread = 2000;

/*
    * Set of variables we update from oTree
    */ 
graph.startingWealth = 20000; 
graph.profit = graph.startingWealth;                                           // Through Django Channels
// graph.adminStartTime = {{subsession.start_time}};           // Django Query

/*
    * HTML Variables
    */
graph.profitElementId = "profit-graph";                                     // id of the profit graph svg element
graph.profitElementWidth = $('#' + graph.profitElementId).width();          // Width and height of the profit svg element
graph.profitElementHeight = $('#' + graph.profitElementId).height();    

/*
    * D3 variables
    */
graph.profitSVG = d3.select('#' + graph.profitElementId);                   //profit svg element
graph.curTimeX = 0;


/*
    * Variables for time calculation
    */
var nanoToSec = 1e9;
var secToNano = 1e-9
var million = 1e6;
graph.timeOffset = 0;                                             //offset to adjust for clock difference between lab computers
graph.timeInterval = 60e9;                                        //current amount in seconds displayed at once on full time axis
graph.timeIncrement = 5e9;                                        // Amount in nanoseconds between lines on time x-axis
graph.timeSinceStart = 0;                                         //the amount of time since the start of the experiment in nanoseconds
graph.nanosecondPerPixel = 0;    //used                           // number of ms represented by one pixel
graph.advanceTimeShown = 0;  //used                               // the amount of time shown to the right of the current time on the graph

/*
    * Manifest deafult values
    */
graph.slowDelay = 5e8;                                             // slow delay is 500 milliseconds = 5e8 nano
graph.fastDelay = 1e8;                                             // slow delay is 100 milliseconds = 1e8 nano
graph.startingWealth = 20000;

// maybe spread on profit graph
graph.priceRange = 10000;
graph.maxPriceProfit = graph.startingWealth + (graph.priceRange / 2);
graph.minPriceProfit = graph.startingWealth - (graph.priceRange / 2);
graph.centerPriceProfit = (graph.maxPriceProfit + graph.minPriceProfit) / 2;

/*
    * DataHistory object sets
    */
// historyDataSet structure = [[startTime, endTime, startProfit, endProfit, state],...] 
graph.profitSegments = [
    {
        startTime:graph.adminStartTime,
        endTime:graph.adminStartTime, 
        startProfit:graph.profit, 
        endProfit:graph.profit,
        state:$("#player_role").text()
    }
];

graph.profitJumps = [];


graph.axisLabelWidth = 40;    //used                                  //Width of area where price axis labels are drawn
graph.graphPaddingRight = 20;  //used                                 // how far from the x axis label that the line stops moving
graph.graphAdjustSpeedProfit = 10;                              //speed that profit price axis adjusts in pixels per frame
graph.numberOfTicks = 10;
graph.profitPriceGridIncrement = graph.priceRange / graph.numberOfTicks;                             //amount between each line on profit price axis

graph.currentTime = 0;                                          // Time displayed on graph
graph.profitPriceLines = [];                                    // The array of price lines
graph.timeLines = [];


// graph.startTime = 0;

function calcPriceGridLines(maxPrice, minPrice, increment) {
    var gridLineVal = minPrice + increment - (minPrice % increment);
    // adjust for mod of negative numbers not being negative
    if(minPrice < 0){
        gridLineVal -= increment;
    }
    var lines = [];
    while (gridLineVal < maxPrice) {
        lines.push(gridLineVal);
        gridLineVal += increment;
    }
    return lines;
};


function calcTimeGridLines(startTime, endTime, increment) {

    if(graph.debug["calcTimeGridLines"]){
        console.log("Call to calculate calTimeGrindLines with scaled values\n   startTime:  " + (startTime / nanoToSec).toFixed(2) + 
            "\n   endTime:    " + (endTime / nanoToSec).toFixed(2) + 
            "\n   difference: " + ((endTime - startTime) / nanoToSec).toFixed(2) + 
            "\n   increment:  " + (increment / nanoToSec) + 
            "\n   adminStart: " + (graph.adminStartTime / nanoToSec).toFixed(2));
    }

    // var timeLineVal = startTime + increment;
    var timeLineVal = startTime - ((startTime - graph.adminStartTime) % increment);
    var lines = [];
    while (timeLineVal < endTime) {
        lines.push(timeLineVal);
        timeLineVal += increment;
    }

    if(graph.debug["calcTimeGridLines"]){
        console.log("Lines post computation: previous set of lines :-: computed set of lines ");
        for(i = 0; i < lines.length; i++){
            console.log("   [" + i + "]    " + ((graph.timeLines[i] - graph.adminStartTime) / nanoToSec).toFixed(2) + "  :-:  " + ((lines[i] - graph.adminStartTime) / nanoToSec).toFixed(2));
        }
    }


    return lines;
};

// return the number of nanoseconds since midnight
// TODO FIND MORE ACCURATE NANO
function getTime(){
    var now = new Date(),
    then = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate(),
    0,0,0),
    diff = now.getTime() - then.getTime(); // difference in milliseconds
    diff *= 1000000; // milli -> nano;
    return  diff; 
};

// returns percent along the x axis your timestamp is 
function mapTimeToXAxis(timeStamp) {
    var percentOffset;
    if (graph.timeSinceStart >= graph.timeInterval) {
        percentOffset = (timeStamp - (graph.currentTime - graph.timeInterval)) / (graph.timeInterval);
    }else {
        percentOffset = (timeStamp - graph.adminStartTime) / graph.timeInterval;
    }
    return (graph.profitElementWidth - graph.axisLabelWidth - graph.graphPaddingRight) * percentOffset;   //changed 7/27/17
};

// return percent from
function mapProfitPriceToYAxis(price) {
    // percent distance from maxPriceProfit
    var percentOffset = (graph.maxPriceProfit - price) / (graph.maxPriceProfit - graph.minPriceProfit);

    // value of the percent offset from top of graph
    return graph.profitElementHeight * percentOffset;      //changed 7/27/17 to fix profit graph
};

function calcPriceBounds() {
    //calc bounds for profit graph

    if (graph.profit > (.2 * graph.minPriceProfit) + (.8 * graph.maxPriceProfit) ||
        graph.profit < (.8 * graph.minPriceProfit) + (.2 * graph.maxPriceProfit)) {
        graph.centerPriceProfit = graph.profit;
    }

    // what is set now
    var curCenterProfit = (graph.maxPriceProfit + graph.minPriceProfit) / 2;

    if (Math.abs(graph.centerPriceProfit - curCenterProfit) > 1000) {
        graph.profitPriceLines = calcPriceGridLines(graph.maxPriceProfit, graph.minPriceProfit, graph.profitPriceGridIncrement);
        //adjust per frame what the max and min should be
        if (graph.centerPriceProfit > curCenterProfit) {
            graph.maxPriceProfit += graph.graphAdjustSpeedProfit;
            graph.minPriceProfit += graph.graphAdjustSpeedProfit;
        } else {
            graph.maxPriceProfit -= graph.graphAdjustSpeedProfit;
            graph.minPriceProfit -= graph.graphAdjustSpeedProfit;
        }
    }
};

function millisToTime(timeStamp) {
    // take nano to seconds
    var secs = (timeStamp - graph.adminStartTime) / nanoToSec;
    var mins = Math.trunc(secs / 60);
    secs %= 60;
    return mins + ":" + ("00" + secs).substr(-2, 2);
};

function drawTimeGridLines() {
    //Draw rectangles for time grid lines
    graph.profitSVG.selectAll("rect.time-grid-box-dark")
        .data(graph.timeLines)
        .enter()
        .append("rect")
        .filter(function (d) {
            // only draw elements that are an even number of increments from the start
            return ((d - graph.adminStartTime) / (graph.timeIncrement)) % 2 == 0;
        })
        .attr("x", function (d) {
            return mapTimeToXAxis(d);
        })
        .attr("y", 0)
        // width of a sinle timeIncrement should be 5 secs ?
        .attr("width", graph.timeIncrement / graph.timeInterval * (graph.profitElementWidth - graph.axisLabelWidth - graph.graphPaddingRight))   
        .attr("height", graph.profitElementHeight)
        .attr("class", "time-grid-box-dark");

        //Draw labels for time grid lines
        graph.profitSVG.selectAll("text.time-grid-line-text")
        .data(graph.timeLines)
        .enter()
        .append("text")
        .attr("text-anchor", "start")
        .attr("x", function (d) {
            return mapTimeToXAxis(d) + 5;
        })
        .attr("y", graph.profitElementHeight - 5)
        .text(function (d) {
            return millisToTime(d)
        })
        .attr("class", "time-grid-line-text");
};

function drawPriceGridLines(priceMapFunction) {
    //hack to fix problem with this not being set correctly for map function
    // priceMapFunction = priceMapFunction.bind(graphRefr);

    //Draw the lines for the price grid lines
    graph.profitSVG.selectAll("line.price-grid-line")
        .data(graph.profitPriceLines)
        .enter()
        .append("line")
        .attr("x1", 0)
        .attr("x2", graph.profitElementWidth - graph.axisLabelWidth)        //changed 7/27/17
        .attr("y1", function (d) {
            return mapProfitPriceToYAxis(d);
        })
        .attr("y2", function (d) {
            return mapProfitPriceToYAxis(d);
        })
        .attr("class", function (d) {
            return d != 0 ? "price-grid-line" : "price-grid-line-zero";
    });
};

function drawPriceAxis(){
    //Draw the text that goes along with the price gridlines and axis
    graph.profitSVG.selectAll("text.price-grid-line-text")
        .data(graph.profitPriceLines)
        .enter()
        .append("text")
        .attr("text-anchor", "start")
        .attr("x", graph.profitElementWidth - graph.axisLabelWidth + 12)  // << why this fuck is this 12
        .attr("y", function (d) {  
            return mapProfitPriceToYAxis(d) + 3;
        })
        .attr("class", "price-grid-line-text")
        .text(function (d) {
            return d / 1000;
    });
};

//draws profit line
function drawProfit(historyDataSet, profitJumps) {
    graph.profitSVG.selectAll("line.my-profit-out line.my-profit-maker line.my-profit-snipe")
        .data(historyDataSet, function (d) {   

        // historyDataSet structure = [[startTime, endTime, startProfit, endProfit, state],...] 
            return d;
        })
        .enter()
        .append("line")
        .filter(function (d) {
            return d.endTime >= (graph.currentTime - graph.timeInterval);
        })
        .attr("x1", function (d) {
            return mapTimeToXAxis(d.startTime);
        })
        .attr("x2", function (d) {
            return mapTimeToXAxis(d.endTime);
        })
        .attr("y1", function (d) {
            return mapProfitPriceToYAxis(d.startProfit);
        })
        .attr("y2", function (d) {
            return mapProfitPriceToYAxis(d.endProfit);
        })
        .attr("class", function (d) {
            // a masterpiece // no fuck you
            return d.state == "OUT" ? "my-profit-out" : (d.state == "MAKER" ? "my-profit-maker" : "my-profit-snipe");
    });

    graph.profitSVG.selectAll("line.positive-profit line.negative-profit")
        .data(profitJumps)      
        // profitJumps structure = {timestamp:(nano), newPrice:(thousands), oldPrice:(thousands)}    
        .enter()
        .append("line")
        .filter(function (d) {
            return d.timestamp >= (graph.currentTime - graph.timeInterval);
        })
        .attr("x1", function (d) {
            return mapTimeToXAxis(d.timestamp);
        })
        .attr("x2", function (d) {
            return mapTimeToXAxis(d.timestamp);
        })
        .attr("y1", function (d) {
            return mapProfitPriceToYAxis(d.oldProfit);     //old profit
        })
        .attr("y2", function (d) {
            return mapProfitPriceToYAxis(d.newProfit);     //current profit
        })
        .attr("class", function (d) {
                return d.oldProfit < d.newProfit ? "my-positive-profit" : "my-negative-profit";
        });   
};


function draw() {

    //Clear the svg elements
    graph.profitSVG.selectAll("*").remove();


    // the current time relative to the backend of otree; graph.timeOffset during the transition
    // is 0, but eventually we will calculate per player what the delay over django channels is 
    graph.currentTime =  getTime() - graph.timeOffset; 
    graph.timeSinceStart = graph.currentTime - graph.adminStartTime;



    // Print to console.log everytime a second occurs
    if((graph.previousTime != Math.trunc(graph.timeSinceStart / nanoToSec)) && graph.debug["secondTick"]){
        graph.previousTime = Math.trunc(graph.timeSinceStart / nanoToSec);
        console.log(graph.previousTime)
    } 

    graph.curTimeX = mapTimeToXAxis(graph.currentTime);

    // recalculate market price bounds
    calcPriceBounds();

    // recalculate if virtual right side of graph is more than a graph.timeIncrement past last graph.timeLine line
    var rightSideOfGraph = graph.timeLines[graph.timeLines.length - 1] + graph.timeIncrement;

    if (graph.currentTime + graph.advanceTimeShown > rightSideOfGraph){
        var startTime = graph.currentTime - graph.timeInterval;
        var endTime = graph.currentTime + graph.advanceTimeShown;
        graph.timeLines = calcTimeGridLines(startTime, endTime, graph.timeIncrement);
    }

    //Invoke all of the draw functions
    drawTimeGridLines();

    
    drawPriceGridLines();



    drawPriceAxis();
    
    /* *****************************************************************************
        * Data Structures present in Redwood front end, and need to be adapted to otree 
        ******************************************************************************/ 

    // historyDataSet = [[startTime, endTime, startProfit, endProfit, state],...] 
    // 2-D array where each index contains a different portion of the profit line *over the entire experiment*
    // Each index has a startTime (nano), endTime (nano), startProfit (thousands), endProfit (thousands) 
    graph.profitSegments[graph.profitSegments.length - 1]["endTime"] = graph.currentTime;
    
    var profitDecrement = 0;
    if(speed){
        profitDecrement = (graph.profitSegments[graph.profitSegments.length - 1]["endTime"] - graph.profitSegments[graph.profitSegments.length - 1]["startTime"]) * -1e-8;
    }


    graph.profitSegments[graph.profitSegments.length - 1]["endProfit"] = graph.profitSegments[graph.profitSegments.length - 1]["startProfit"] + profitDecrement;
    graph.profit = graph.profitSegments[graph.profitSegments.length - 1]["startProfit"] + profitDecrement;

    
    

    drawProfit(graph.profitSegments, graph.profitJumps);
    


    requestAnimationFrame(draw);
};

function init(startFP, startingWealth) {
    for(i = 2; i < arguments.length; i++){
        graph.debug[arguments[i]] = true;
    }

    graph.previousTime = 0;

    // nanoseconds per picxel 
    graph.nanosecondPerPixel = graph.timeInterval / (graph.profitElementWidth - graph.axisLabelWidth - graph.graphPaddingRight);   
    // the amount of nano taken up by the axisLabelWidth ad graphPadding riht
    graph.advanceTimeShown = graph.nanosecondPerPixel * (graph.axisLabelWidth + graph.graphPaddingRight);

    // collect an array of price values where the horizontal lines will be drawn
    graph.profitPriceLines = calcPriceGridLines(graph.maxPriceProfit, graph.minPriceProfit, graph.profitPriceGridIncrement);

    var endTime = graph.adminStartTime + graph.timeInterval + graph.advanceTimeShown
    graph.timeLines = calcTimeGridLines(graph.adminStartTime, endTime, graph.timeIncrement);
};


// First Functions
// 10000 <- 
var startFP = 10000;
var startingWealth = 20000;

// init(startFP, startingWealth, "secondTick");

// requestAnimationFrame(draw)



}
</script>
{% endblock %}
 